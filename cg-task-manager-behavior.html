<link rel="import" href="../cg-utils/cg-utils.html">
<link rel="import" href="../cg-behaviors/cg-base-behavior.html">
<link rel="import" href="../cg-behaviors/cg-document-event-behavior.html">
<link rel="import" href="cg-task-scripts.html">

<script>
    var Tasks = {
        scheduled:[],
        running:[],
        success:[],
        error:[],
        canceled:[],
    };

    var CGTaskManagerBehavior = {
        properties:{
            loopDelay:{
                value:100
            },
            tasks:{
                type:Object
            },
            manager:{
                type:Boolean,
                value:false
            },
            tasksPerType:{
                type:Object,
                value:function(){
                    return {
                        "scheduled":{
                            value:Tasks.scheduled,
                            name:"tasks.scheduled"
                        },
                        "running":{
                            value:Tasks.running,
                            name:"tasks.running"
                        },
                        "success":{
                            value:Tasks.success,
                            name:"tasks.success"
                        },
                        "canceled":{
                            value:Tasks.canceled,
                            name:"tasks.canceled"
                        },
                        "failed":{
                            value:Tasks.error,
                            name:"tasks.error"
                        }
                    }
                }
            },
            maxConcurrent:{
                value:1
            }
        },
        observers:[
            "notifyTasksChanged(tasks.*)"
        ],
        _tasksLoop:null,
        ready:function(){
            this.listensTo("cg-tasks", this._onTasksChangeEvent);
            this.tasks = Tasks;
            if(this.manager) {
                this._tasksLoop = setInterval(this._taskLoop.bind(this), this.loopDelay);
            }
        },
        _getNextRunnableTask:function(){
            var task = null;
            var i = 0;
            while(i < this.tasks.scheduled.length){
                var t = this.tasks.scheduled[i++];
                if(!t.dependsOn || t.dependsOn.info.success) {
                    task = t;
                    break;
                }
            }
            return task;
        },
        _onTasksChangeEvent:function(type, event, e){
            switch(type) {
                case "changed":
                    console.log(this.toString(), "_onTasksChangeEvent", event.params.path);
                    this.notifyPath(event.params.path, event.params.value);
                    if(event.params.path.indexOf(".length") != -1) {
                        this.onTaskSizeChanged(this.tasks, event.params.path);
                    }
                    break;
                case "schedule-task":
                    this.manager && this.scheduleTask(event.params);
                    break;
                case "schedule-tasks":
                    this.manager && event.params.forEach(function(task){
                        this.scheduleTask(task)
                    }, this);
                    break;
                default:
                    this.onTasksEvent(type, event, e);
                    break;
            }
        },
        onTasksEvent:function(type, event, e){},
        onTaskSizeChanged:function(tasks, path){},
        notifyTasksChanged:function(change){
            if(!this.manager) return;
            this.fireTasksEvent("changed", {
                path: change.path,
                value: change.value
            }, this);
        },
        fireTasksEvent:function(type, payload){
            this.fireDocument("cg-tasks", type, payload, this);
        },
        _taskLoop:function(){
            while(this.tasks.scheduled.length > 0 && this.tasks.running.length < this.maxConcurrent){
                var task = this._getNextRunnableTask();
                if(!task) break;
                this.arrayDelete("tasks.scheduled", task);
                if(task.info.canceled) {
                    this.push("tasks.canceled", task);
                    continue;
                }
                this.push("tasks.running", task);
                console.log(this.toString(), "Running task", task.toString());
                task.exec(function(event, data, task){
                    switch(event){
                        case "finished":
                            console.log(this.toString(), "Task finished", task.toString());
                            this.arrayDelete("tasks.running", task);
                            task.info.finished = true;
                            task.info.success = data.success || false;
                            task.info.canceled = data.canceled || false;
                            task.info.discarded = data.discarded || false;
                            task.info.data = data.data;
                            task.info.error = data.error || false;
                            if(data.success) {
                                this.push("tasks.success", task);
//                            }else if(data.canceled){
//                                this.push("tasks.canceled", task);
                            }else if(!data.canceled){
                                this.push("tasks.error", task);
                            }
                            break;
                        case "progress":
                            //console.log(this.toString(), "Task progress", task.toString(), "data", JSON.stringify(data));
                            this.set("tasks.running." + this.tasks.running.indexOf(task) + ".info.progress", data.progress);
                            break;
                    }
                }.bind(this));
            }
        },
        getTasks:function(){
            return this.tasks.scheduled
                    .concat(this.tasks.running)
                    .concat(this.tasks.success)
                    .concat(this.tasks.error)
                    .concat(this.tasks.canceled);
        },
        scheduleTask:function(task){
            task.reset();
            task.setManager(this);
            console.log(this.toString(), "Scheduling task", task.toString());
            this.push("tasks.scheduled", task);
            return task;
        },
        schedule:function(desc, jobFn, jobArgs, jobScope, callback, dependsOn){
            return this.scheduleTask(new CG.Task(desc, jobFn, jobArgs, jobScope, callback, dependsOn));
        },
        cancel:function(task, type){
            var tasks = this._getTasksFor(type, task);
            this.arrayDelete(tasks.name, task);
            this.push("tasks.canceled", task);
        },
        discard:function(task, type){
            var tasks = this._getTasksFor(type, task);
            this.arrayDelete(tasks.name, task);
        },
        retry:function(task, type){
            var tasks = this._getTasksFor(type, task);
            this.arrayDelete(tasks.name, task);
            this.scheduleTask(task);
        },
        _getTasksFor:function(type, task){
            return type ? this._getTasksForType(type) : this._getTasksByTask(task);
        },
        _getTasksForType:function(type){
            return this.tasksPerType[type];
        },
        _getTasksByTask:function(task){
            for(var key in this.tasksPerType){
                if(this.tasksPerType[key].value.indexOf(task) != -1) {
                    return this.tasksPerType[key];
                }
            }
            return null;
        },
    };
    CG.TaskManagerBehavior = [CG.BaseBehavior, CGTaskManagerBehavior, CG.DocumentEventBehavior];
</script>